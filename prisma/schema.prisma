generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  MEMBER
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  WON
  LOST
}

enum BillingType {
  ONE_TIME
  RECURRING
}

enum OrderStatus {
  PENDING
  PAID
  CANCELED
  REFUNDED
  FAILED
}

enum SubscriptionStatus {
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  PAUSED
}

enum BriefingStatus {
  DRAFT
  SUBMITTED
}

model User {
  id    String   @id @default(cuid())
  email String   @unique
  name  String?
  role  UserRole @default(MEMBER)

  // Stripe
  stripeCustomerId String? @unique

  orders        Order[]
  subscriptions Subscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdAt])
}

model Lead {
  id      String     @id @default(cuid())
  email   String?
  name    String?
  phone   String?
  message String?
  source  String? // ex: "whatsapp", "form", "cta-hero"
  status  LeadStatus @default(NEW)

  // Marketing attribution
  utmSource   String?
  utmMedium   String?
  utmCampaign String?
  utmContent  String?
  utmTerm     String?
  referrer    String?
  landingPath String?

  orders Order[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, createdAt])
  @@index([email])
}

model Product {
  id          String  @id @default(cuid())
  slug        String  @unique // ex: "platform-basic", "platform-pro"
  name        String
  description String?
  active      Boolean @default(true)

  prices Price[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Price {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  billingType BillingType @default(ONE_TIME)

  // valores em centavos
  currency   String @default("brl")
  unitAmount Int

  // Para recorrência (opcional): "month", "year"
  interval String? // use apenas se billingType = RECURRING

  active Boolean @default(true)

  // Stripe
  stripePriceId String @unique

  orders        Order[]
  subscriptions Subscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId, active])
  @@index([billingType])
}

model Order {
  id String @id @default(cuid())

  // O pedido pode vir de:
  // - usuário logado (User)
  // - lead (Lead) (ex: WhatsApp ou formulário sem login)
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  leadId String?
  lead   Lead?   @relation(fields: [leadId], references: [id], onDelete: SetNull)

  // Importante: manter Price como "fonte interna" do plano adquirido.
  // No webhook você mapeia stripePriceId -> Price.id
  priceId String
  price   Price  @relation(fields: [priceId], references: [id], onDelete: Restrict)

  quantity Int    @default(1)
  currency String @default("brl")

  upsells UpsellPurchase[]

  upsellFollowup UpsellFollowup?
  // snapshot do total no momento da compra (centavos)
  amountSubtotal Int
  amountDiscount Int             @default(0)
  amountTotal    Int

  status       OrderStatus   @default(PENDING)
  stripeEvents StripeEvent[] @relation("OrderStripeEvents")

  // Stripe (checkout + pagamento)
  // Mantido como opcional para permitir criar Order antes/depois do checkout, mas:
  // - no fluxo recomendado, você cria Order no "create checkout" e já salva o sessionId
  stripeCheckoutSessionId String? @unique
  stripePaymentIntentId   String? @unique

  // Snapshots úteis do Stripe (para UX, auditoria e suporte)
  stripeCustomerId String?
  customerEmail    String?

  // Metadata do checkout (ex.: userId, productKey, leadId, etc.) para debug/auditoria
  stripeMetadata Json?

  paidAt    DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Briefing (wizard) — 1:1 com o pedido
  briefing Briefing?

  // ✅ Magic links (sem login) — 1:N com Order
  accessLinks OrderAccessLink[]

  @@index([userId, createdAt])
  @@index([leadId, createdAt])
  @@index([status, createdAt])
  @@index([priceId])
}

model Briefing {
  id String @id @default(cuid())

  orderId String @unique
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  status BriefingStatus @default(DRAFT)

  // Autosave do wizard (payload livre, evolutivo)
  data Json?

  submittedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([status, createdAt])
}

model Subscription {
  id String @id @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  priceId String
  price   Price  @relation(fields: [priceId], references: [id], onDelete: Restrict)

  status SubscriptionStatus @default(INCOMPLETE)

  // Stripe
  stripeSubscriptionId String @unique

  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  cancelAtPeriodEnd  Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, status])
  @@index([priceId])
}

model StripeEvent {
  id            String   @id @default(cuid())
  stripeEventId String   @unique
  type          String
  apiVersion    String?
  createdAt     DateTime @default(now())
  payload       Json

  processedAt DateTime?

  orderId String?
  order   Order?  @relation("OrderStripeEvents", fields: [orderId], references: [id], onDelete: SetNull)

  @@index([type, createdAt])
  @@index([orderId])
}

enum UpsellStatus {
  PENDING
  PAID
  CANCELED
}

model UpsellPurchase {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  kind   String // "hosting"
  status UpsellStatus @default(PENDING)

  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  stripeCheckoutSessionId String? @unique
  stripePaymentIntentId   String? @unique

  amountTotal Int?
  currency    String?

  @@index([orderId, kind])
  @@index([status, createdAt])
}

model OrderAccessLink {
  id String @id @default(cuid())

  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Salvar apenas o hash do token (nunca o token puro)
  tokenHash String @unique

  // Controle de validade e revogação
  expiresAt DateTime
  revokedAt DateTime?

  // Auditoria e base para recuperação
  destinationEmail String?
  destinationPhone String?

  // Auditoria de uso
  lastUsedAt DateTime?
  useCount   Int       @default(0)

  // Base para rate-limit de reenvio
  lastSentAt DateTime?
  sendCount  Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([expiresAt])
}

enum AdminWorkItemKind {
  READY
  STALLED
  LEAD
  UPSELL
}

enum AdminWorkItemStatus {
  TODO
  IN_PROGRESS
  DONE
  SNOOZED
}

model AdminWorkItem {
  id          String              @id @default(cuid())
  kind        AdminWorkItemKind
  refId       String
  status      AdminWorkItemStatus @default(TODO)
  note        String?
  snoozeUntil DateTime?
  doneAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([kind, refId])
  @@index([kind, status])
}

model UpsellFollowup {
  id         String    @id @default(cuid())
  orderId    String    @unique
  kind       String
  attempts   Int       @default(0)
  lastSentAt DateTime?
  closeAt    DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([kind])
  @@index([closeAt])
}
