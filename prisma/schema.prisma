generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  MEMBER
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  WON
  LOST
}

enum BillingType {
  ONE_TIME
  RECURRING
}

enum OrderStatus {
  PENDING
  PAID
  CANCELED
  REFUNDED
  FAILED
}

enum SubscriptionStatus {
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  PAUSED
}

model User {
  id               String   @id @default(cuid())
  email            String   @unique
  name             String?
  role             UserRole @default(MEMBER)

  // Stripe
  stripeCustomerId String?  @unique

  orders           Order[]
  subscriptions    Subscription[]

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([createdAt])
}

model Lead {
  id        String     @id @default(cuid())
  email     String?
  name      String?
  phone     String?
  message   String?
  source    String?    // ex: "whatsapp", "form", "cta-hero"
  status    LeadStatus @default(NEW)

  // Marketing attribution
  utmSource   String?
  utmMedium   String?
  utmCampaign String?
  utmContent  String?
  utmTerm     String?
  referrer    String?
  landingPath String?

  orders     Order[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([status, createdAt])
  @@index([email])
}

model Product {
  id          String  @id @default(cuid())
  slug        String  @unique // ex: "platform-basic", "platform-pro"
  name        String
  description String?
  active      Boolean @default(true)

  prices      Price[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Price {
  id            String      @id @default(cuid())
  productId     String
  product       Product     @relation(fields: [productId], references: [id], onDelete: Cascade)

  billingType   BillingType @default(ONE_TIME)

  // valores em centavos
  currency      String      @default("brl")
  unitAmount    Int

  // Para recorrência (opcional): "month", "year"
  interval      String?     // use apenas se billingType = RECURRING

  active        Boolean     @default(true)

  // Stripe
  stripePriceId String      @unique

  orders        Order[]
  subscriptions Subscription[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([productId, active])
  @@index([billingType])
}

model Order {
  id                      String      @id @default(cuid())

  // O pedido pode vir de:
  // - usuário logado (User)
  // - lead (Lead) (ex: WhatsApp ou formulário sem login)
  userId                  String?
  user                    User?       @relation(fields: [userId], references: [id], onDelete: SetNull)

  leadId                  String?
  lead                    Lead?       @relation(fields: [leadId], references: [id], onDelete: SetNull)

  priceId                 String
  price                   Price       @relation(fields: [priceId], references: [id])

  quantity                Int         @default(1)
  currency                String      @default("brl")

  // snapshot do total no momento da compra (centavos)
  amountSubtotal          Int
  amountDiscount          Int         @default(0)
  amountTotal             Int

  status                  OrderStatus @default(PENDING)

  // Stripe (checkout + pagamento)
  stripeCheckoutSessionId String?     @unique
  stripePaymentIntentId   String?     @unique

  paidAt                  DateTime?
  createdAt               DateTime    @default(now())
  updatedAt               DateTime    @updatedAt

  @@index([userId, createdAt])
  @@index([leadId, createdAt])
  @@index([status, createdAt])
  @@index([priceId])
}

model Subscription {
  id                   String             @id @default(cuid())

  userId               String
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  priceId              String
  price                Price              @relation(fields: [priceId], references: [id])

  status               SubscriptionStatus @default(INCOMPLETE)

  // Stripe
  stripeSubscriptionId String             @unique

  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@index([userId, status])
  @@index([priceId])
}

model StripeEvent {
  id            String   @id @default(cuid())
  stripeEventId String   @unique
  type          String
  apiVersion    String?
  createdAt     DateTime @default(now())

  // payload completo (para auditoria / debug)
  payload       Json

  @@index([type, createdAt])
}
